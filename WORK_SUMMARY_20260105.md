# 작업 요약 및 오도메트리 개선 제안 보고서 (2026-01-05)

## 1. 작업 요약 (Work Summary)

오늘 진행된 주요 작업 내역입니다. 휠 인코더가 제거된 로봇을 정상적으로 주행시키기 위해 **"Fake Odometry" (Open Loop)** 시스템을 구축하고 최적화했습니다.

### A. 하드웨어 및 드라이버 수정
1.  **IMU 데이터 복구**:
    *   **문제**: 시리얼 통신 불안정으로 IMU 데이터가 0으로 나오는 현상.
    *   **해결**: `jupiter_driver.py`에 Watchdog 기능을 추가하여 데이터가 0일 경우 자동으로 통신을 재설정하도록 수정.
2.  **회전 방향 수정**:
    *   **문제**: 로봇 회전 시 Rviz 상의 로봇이 반대로 회전.
    *   **해결**: `Rosmaster_Lib.py`의 하드코딩된 부호 제거 및 `jupiter_driver.py`에 `imu_invert_z` 파라미터 추가.
3.  **Fake Odometry 구현**:
    *   **문제**: 인코더 제거로 인해 속도 피드백이 0이 되어 네비게이션 불가능.
    *   **해결**: `cmd_vel` 명령어를 실제 속도로 가정하여 오도메트리를 생성하는 로직 구현.

### B. 캘리브레이션 및 튜닝
1.  **회전 스케일 보정**:
    *   **작업**: 실제 360도 회전 시 IMU 값을 측정.
    *   **결과**: `sensitivity_gain`을 **1.0021**로 보정하여 회전 정확도 확보.
2.  **Nav2 파라미터 최적화**:
    *   **속도 제한**: 하드웨어 한계에 맞춰 최대 속도 하향 (선형 0.36 m/s, 회전 2.85 rad/s).
    *   **최소 속도 설정**: 모터가 움직이기 시작하는 최소 전압을 고려하여 최소 속도 설정 (선형 0.20 m/s, 회전 2.5 rad/s).
3.  **드리프트 방지 (Deadzone Logic)**:
    *   **문제**: Nav2가 부드러운 출발을 위해 낮은 속도 명령을 보낼 때, 로봇은 실제로 움직이지 않지만 오도메트리는 적분되어 위치 오차(드리프트) 발생.
    *   **해결**: 드라이버 레벨에서 **선형 0.20 m/s, 회전 2.5 rad/s 미만**의 명령은 오도메트리 계산에서 무시하도록 처리.

---

## 2. 오도메트리 정확도 향상 방법론 (Recommendations)

현재 시스템은 바퀴의 회전을 감지하는 센서(인코더)가 없기 때문에, **"명령한 대로 갔을 것이다"**라고 추측하는 방식(Open Loop)을 사용합니다. 이를 보완하고 정확도를 더 올리기 위한 방법들입니다.

### 1단계: 선형(Linear) 스케일 캘리브레이션 (즉시 적용 가능)
회전(Angular)은 360도 테스트로 보정했지만, 직진(Linear) 거리는 아직 보정되지 않았습니다.
*   **방법**: 바닥에 줄자로 **1m**를 표시하고, 로봇을 정확히 1m 주행시킵니다. 이때 `odom` 토픽이 기록한 거리가 1.0m인지 확인합니다.
*   **적용**: 만약 `odom`이 0.9m라고 나온다면, 드라이버 코드에서 선형 속도에 보정 계수(예: `1.0 / 0.9 = 1.11`)를 곱해줍니다.

### 2단계: Lidar Odometry (RF2O) 도입 (소프트웨어적 해결)
바퀴 대신 **라이다(Lidar)** 센서를 사용하여 이동 거리를 계산하는 방법입니다.
*   **원리**: 연속된 라이다 스캔 데이터를 비교하여 로봇이 얼마나 이동했는지 계산합니다.
*   **장점**: 바퀴가 미끄러지거나 헛돌아도 정확한 위치 추정이 가능합니다.
*   **추천 패키지**: `rf2o_laser_odometry` (ROS 2 호환 패키지 사용).
*   **구성**: `cmd_vel` 기반의 Fake Odom 대신, RF2O가 발행하는 `odom`을 EKF에 입력으로 사용합니다.

### 3단계: Visual Odometry (카메라 활용)
로봇에 장착된 카메라(Astra 등)를 활용합니다.
*   **원리**: 카메라 영상의 특징점을 추적하여 이동을 계산합니다.
*   **장점**: 라이다가 특징을 잡기 힘든 긴 복도나 넓은 공간에서 유리합니다.
*   **단점**: 조명 변화에 민감하고 CPU 사용량이 높습니다. (Jetson Orin Nano에서는 사용 가능)

### 4단계: SLAM 매칭 의존도 높이기
AMCL이나 SLAM Toolbox의 스캔 매칭 파라미터를 더 공격적으로 설정합니다.
*   **방법**: `nav2_params.yaml`이나 `amcl.yaml`에서 오도메트리 노이즈(`alpha` 값)를 매우 크게 설정하고, 레이저 스캔의 신뢰도를 높입니다.
*   **효과**: 오도메트리가 틀려도 라이다가 벽을 보고 위치를 강제로 수정합니다. (현재 이미 일부 적용됨)

### 5단계: 하드웨어 복구 (가장 확실한 방법)
*   가능하다면 **휠 인코더**를 다시 장착하는 것이 가장 좋습니다. 물리적인 센서 피드백 없이는 미끄러짐이나 외력에 의한 위치 변화를 감지할 수 없습니다.

### 요약
현재 상황에서 가장 현실적이고 효과적인 다음 단계는 **"1단계: 선형 스케일 캘리브레이션"**을 수행하고, 그래도 부족하다면 **"2단계: Lidar Odometry"**를 도입하는 것입니다.
