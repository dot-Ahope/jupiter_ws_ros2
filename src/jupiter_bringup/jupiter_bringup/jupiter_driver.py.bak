#!/usr/bin/env python3
# encoding: utf-8
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', '..', 'Transbot', 'transbot'))

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rcl_interfaces.msg import ParameterDescriptor, FloatingPointRange, ParameterType
from std_msgs.msg import Float32
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Twist
from transbot_msgs.srv import RobotArm
from . import utilities
import math
import threading
import time
from Transbot_Lib import Transbot
from . import arm_transbot
from .arm_transbot import Transbot_ARM

class TransbotDriver(Node):
    def __init__(self):
        super().__init__('transbot_driver')
        
        # Initialize hardware with retry mechanism
        max_retries = 3
        for attempt in range(max_retries):
            try:
                self.bot = Transbot(com="/dev/ttyTHS1", delay=0.002)
                # Create receive thread to handle IMU and velocity data
                self.bot.create_receive_threading()
                # Enable auto reporting for IMU and velocity data
                self.bot.set_auto_report_state(True)
                # Test communication
                self.bot.set_motor(1, 0)
                self.bot.set_motor(2, 0)
                self.get_logger().info("Transbot hardware initialized successfully on /dev/ttyTHS1")
                break
            except Exception as e:
                if attempt < max_retries - 1:
                    self.get_logger().warn(f"Failed to initialize hardware (attempt {attempt + 1}): {str(e)}")
                    time.sleep(1)
                else:
                    self.get_logger().error(f"Failed to initialize hardware after {max_retries} attempts: {str(e)}")
                    raise
        
        # Declare parameters with constraints  
        self.declare_parameter('Kp', 0.5,
            ParameterDescriptor(
                type=ParameterType.PARAMETER_DOUBLE,
                floating_point_range=[FloatingPointRange(
                    from_value=0.0,
                    to_value=2.0,
                    step=0.01
                )],
                description='Proportional gain'
            ))
            
        self.declare_parameter('Ki', 0.0,
            ParameterDescriptor(
                type=ParameterType.PARAMETER_DOUBLE,
                floating_point_range=[FloatingPointRange(
                    from_value=0.0,
                    to_value=1.0,
                    step=0.01
                )],
                description='Integral gain'
            ))
            
        self.declare_parameter('Kd', 0.0,
            ParameterDescriptor(
                type=ParameterType.PARAMETER_DOUBLE,
                floating_point_range=[FloatingPointRange(
                    from_value=0.0,
                    to_value=1.0,
                    step=0.01
                )],
                description='Derivative gain'
            ))
            
        # Create publishers
        self.imu_pub = self.create_publisher(
            Imu, 
            '/transbot/imu', 
            10
        )
        self.vel_pub = self.create_publisher(
            Twist, 
            '/transbot/get_vel', 
            10
        )
        
        # Initialize robot arm
        try:
            self.arm = Transbot_ARM()
            self.get_logger().info("Robot arm initialized successfully")
        except Exception as e:
            self.get_logger().error(f"Failed to initialize robot arm: {str(e)}")
            raise

        # Create subscribers
        self.cmd_vel_sub = self.create_subscription(
            Twist,
            '/cmd_vel',
            self.cmd_vel_callback,
            10
        )
        
        # Create RobotArm service
        self.srv_CurrentAngle = self.create_service(
            RobotArm,
            '/CurrentAngle',
            self.RobotArmCallback
        )
        
        # Add parameter callback
        self.add_on_set_parameters_callback(self.parameter_callback)
        
        # Create timers
        self.create_timer(0.1, self.publish_imu)  # 10Hz
        self.create_timer(0.1, self.publish_velocity)  # 10Hz
        
        self.get_logger().info('Transbot Driver Node has been initialized')
        
    def parameter_callback(self, params):
        """Handle parameter updates"""
        for param in params:
            if param.name in ['Kp', 'Ki', 'Kd']:
                # Update PID parameters
                kp = self.get_parameter('Kp').value
                ki = self.get_parameter('Ki').value
                kd = self.get_parameter('Kd').value
                # Update PID values in robot hardware
                if hasattr(self.bot, 'set_pid'):
                    self.bot.set_pid(kp, ki, kd)
        return True
        
    def cmd_vel_callback(self, msg):
        """Handle incoming velocity commands"""
        try:
            # Convert twist message to motor commands
            linear_x = msg.linear.x
            angular_z = msg.angular.z
            
            # Simple differential drive conversion
            max_speed = 30  # limit to 30% for safety
            
            # For forward/backward motion
            base_speed = linear_x * (100.0 / 0.2)  # Scale from m/s to percentage
            # For rotation
            turn_speed = angular_z * (100.0 / 0.5)  # Scale from rad/s to percentage
            
            # Calculate wheel speeds
            left_speed = int(base_speed - turn_speed)
            right_speed = int(base_speed + turn_speed)
            
            # Limit speeds to valid range (-100 to 100)
            left_speed = max(min(left_speed, 100), -100)
            right_speed = max(min(right_speed, 100), -100)
            
            # Print debug information and ensure proper type conversion
            left_speed = int(left_speed)
            right_speed = int(right_speed)
            self.get_logger().info(f'Setting motors: L={left_speed}, R={right_speed}')
            
            # Send commands to motors with small delay between commands
            try:
                # Left motor
                self.bot.set_motor(1, left_speed)
                self.get_logger().info(f'Left motor command sent: {left_speed}')
                time.sleep(0.01)  # Small delay between commands
                
                # Right motor
                self.bot.set_motor(2, right_speed)
                self.get_logger().info(f'Right motor command sent: {right_speed}')
                
            except Exception as e:
                self.get_logger().error(f'Failed to send motor command: {str(e)}')
            
        except Exception as e:
            self.get_logger().error(f'Failed to set velocity: {str(e)}')
            
    # 이동 평균 필터를 위한 데이터 저장 배열
    imu_data_buffer = {
        'ax': [], 'ay': [], 'az': [],
        'gx': [], 'gy': [], 'gz': []
    }
    buffer_size = 2  # 버퍼 크기 (필터링 정도) - 민감도 향상을 위해 5에서 2로 감소

    def apply_moving_average(self, value, buffer_name):
        """이동 평균 필터 적용"""
        # 버퍼에 현재 값 추가
        if len(self.imu_data_buffer[buffer_name]) >= self.buffer_size:
            self.imu_data_buffer[buffer_name].pop(0)
        self.imu_data_buffer[buffer_name].append(value)
        
        # 이동 평균 계산
        return sum(self.imu_data_buffer[buffer_name]) / len(self.imu_data_buffer[buffer_name])

    def publish_imu(self):
        """Publish IMU data"""
        try:
            # Get accelerometer and gyroscope data
            ax, ay, az = self.bot.get_accelerometer_data()
            gx, gy, gz = self.bot.get_gyroscope_data()
            
            # 이동 평균 필터 적용
            ax = self.apply_moving_average(ax, 'ax')
            ay = self.apply_moving_average(ay, 'ay')
            az = self.apply_moving_average(az, 'az')
            gx = self.apply_moving_average(gx, 'gx')
            gy = self.apply_moving_average(gy, 'gy')
            gz = self.apply_moving_average(gz, 'gz')
            
            msg = Imu()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.header.frame_id = "imu_link"
            
            # 적절한 공분산 값 설정 (노이즈 수준 추정)
            accel_cov = 0.01  # 가속도 측정 불확실성 (m/s^2)^2
            gyro_cov = 0.001  # 각속도 측정 불확실성 (rad/s)^2
            
            # 초기 공분산 행렬 설정
            msg.orientation_covariance = [-1.0] * 9  # 방향은 여전히 제공되지 않음
            
            # 각속도 공분산 (대각선에 불확실성 값 설정)
            msg.angular_velocity_covariance = [
                gyro_cov, 0.0, 0.0,
                0.0, gyro_cov, 0.0,
                0.0, 0.0, gyro_cov
            ]
            
            # 선형 가속도 공분산 (대각선에 불확실성 값 설정)
            msg.linear_acceleration_covariance = [
                accel_cov, 0.0, 0.0,
                0.0, accel_cov, 0.0,
                0.0, 0.0, accel_cov
            ]
            
            # Fill in angular velocity (rad/s)
            msg.angular_velocity.x = float(gx)
            msg.angular_velocity.y = float(gy) 
            msg.angular_velocity.z = float(gz)
            
            # Fill in linear acceleration (m/s^2)
            msg.linear_acceleration.x = float(ax)
            msg.linear_acceleration.y = float(ay)
            msg.linear_acceleration.z = float(az)
            
            # Publish the message
            self.imu_pub.publish(msg)
            
        except Exception as e:
            self.get_logger().error(f'Failed to publish IMU data: {str(e)}')
            
    def publish_velocity(self):
        """Publish current velocity"""
        try:
            # Get current velocity from hardware
            vel, ang = self.bot.get_velocity()
            
            # Create and fill velocity message
            msg = Twist()
            msg.linear.x = float(vel)  # linear velocity in m/s
            msg.angular.z = float(ang)  # angular velocity in rad/s
            
            # Publish velocity data
            self.vel_pub.publish(msg)
            
        except Exception as e:
            self.get_logger().error(f'Failed to publish velocity data: {str(e)}')
            
    def RobotArmCallback(self, request, response):
        """Handle RobotArm service requests"""
        try:
            if request.command == "getJoint":
                # Get current joint angles
                current_angles = self.arm.get_current_angles()
                if current_angles is not None and len(current_angles) >= 3:
                    response.angles = [float(angle) for angle in current_angles[:3]]
                    response.result = True
                    self.get_logger().info(f'Current joint angles: {response.angles}')
                else:
                    response.result = False
                    self.get_logger().warn('Failed to get joint angles')
            else:
                # Handle other commands if needed
                response.result = False
                self.get_logger().warn(f'Unknown RobotArm command: {request.command}')
        except Exception as e:
            response.result = False
            self.get_logger().error(f'RobotArm service error: {str(e)}')
        
        return response

    def destroy_node(self):
        """Cleanup when node is shut down"""
        try:
            # Stop motors
            self.bot.set_motor(1, 0)
            self.bot.set_motor(2, 0)
        except:
            self.get_logger().warn('Failed to stop motors during shutdown')
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = TransbotDriver()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
