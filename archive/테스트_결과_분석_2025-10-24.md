# EKF 비교 테스트 결과 분석 (2025-10-24)

## 🚨 심각한 문제 발견

### 테스트 환경
- **Angular Scale**: 1.5618 (이전 값, 1.8819로 업데이트했으나 시스템 재시작 전)
- **Process Noise**: 0.00005 (새로 적용)
- **날짜**: 2025-10-24

---

## 📊 핵심 발견사항

### 1️⃣ **Odom 측정값의 심각한 비대칭 (17.71°)**

```
IMU 기준 90° 회전:
  반시계: Odom 80.40° (10° 부족)
  시계:   Odom 98.11° (8° 초과)
  비대칭: 17.71° ← 매우 심각!

비교:
  IMU 비대칭: 0.72° (양호)
  Odom 비대칭: 17.71° (24배 차이!)
```

**의미**: 
- Odom은 **방향에 따라 완전히 다른 측정값** 제공
- 반시계: 29% 언더측정 (80.40/90 = 89%)
- 시계: 9% 오버측정 (98.11/90 = 109%)
- **Angular scale로 단순 보정 불가능** (비선형 오차)

---

### 2️⃣ **EKF 융합 실패 패턴**

#### Test 1 (IMU 반시계): **EKF가 IMU/Odom 둘 다 무시!**
```
IMU:  89.94° (정확)
Odom: 80.40° 
EKF:  63.84° ← IMU보다 26° 낮음, Odom보다 16° 낮음!
```

**분석**:
- EKF가 둘 다 거부하고 **이전 상태 유지** (관성)
- Process noise (0.00005)가 **너무 낮아서** 센서 변화를 신뢰하지 않음
- 또는 센서 간 불일치(9.5° 차이)로 Mahalanobis 거리 초과

#### Test 2 (IMU 시계): **EKF = Odom (100%)**
```
IMU:  89.22°
Odom: 98.11°
EKF:  98.11° ← Odom과 완전 일치
```

**분석**:
- Odom만 신뢰, IMU 무시 (이전과 동일 패턴)
- Process noise 감소가 **역효과** (센서 거부 증가)

#### Test 3-4 (Odom 기준): **EKF = Odom (100%)**
```
모든 경우 EKF가 Odom과 완전 일치
  Test 3: 130.28° = 130.28°
  Test 4: 124.56° = 124.56°
```

---

### 3️⃣ **Process Noise 0.00005의 부작용**

#### Kalman Filter 이론
```
K = P / (P + R)

현재 설정:
  P (Process Noise): 0.00005
  R_IMU: 0.0001
  R_Odom: 0.01
  
Kalman Gain:
  K_IMU = 0.00005 / 0.00015 = 0.33 (33%)
  K_Odom = 0.00005 / 0.01005 = 0.005 (0.5%)

센서 신뢰도:
  IMU: 1 - 0.33 = 67% (높음)
  Odom: 1 - 0.005 = 99.5% (매우 높음)
```

**문제**: Process noise가 **너무 낮으면**:
1. **센서 거부 증가**: Innovation (측정값 - 예측값)이 크면 이상치로 판단
2. **상태 고착**: 이전 상태에 과도하게 의존
3. **동적 응답 저하**: 실제 움직임 추적 실패

#### 증거
```
Test 1에서:
  예측 상태: ~64° (이전 상태)
  IMU 측정: 89.94° (차이 26°)
  Odom 측정: 80.40° (차이 16°)
  
  Innovation이 모두 크므로 → 둘 다 거부 → 이전 상태 유지
  결과: EKF = 63.84° (예측값 그대로)
```

---

### 4️⃣ **Odom Raw 비대칭의 근본 원인**

#### 원시값 분석
```
반시계 회전:
  Odom 측정: 80.40°
  Raw (scale 전): 51.48° (80.40/1.5618)
  
시계 회전:
  Odom 측정: 98.11°
  Raw (scale 전): 62.82° (98.11/1.5618)
  
원시값 차이: 62.82 - 51.48 = 11.34°
IMU 차이: 89.94 - 89.22 = 0.72°
```

**결론**: **Raw 값부터 비대칭** (하드웨어 문제)

#### 가능한 원인

1. **엔코더 슬립 방향성**
   - 반시계: 휠 슬립 → 언더측정
   - 시계: 휠 그립 → 오버측정
   - 원인: 모터 특성, 바닥 마찰 비대칭

2. **기어 백래시 (Backlash)**
   - 방향 전환 시 기어 간극으로 손실
   - 반시계 회전 후 정지: 간극만큼 손실
   - 시계 회전: 간극 압축으로 과측정

3. **엔코더 펄스 카운트 오류**
   - MCU 펌웨어에서 방향별 다른 처리
   - 인터럽트 타이밍 문제

4. **베어링/축 마찰 비대칭**
   - 한쪽 휠의 마찰이 더 큼
   - 로봇이 약간 기울어져 있음

---

## 🔍 심층 분석

### Angular Scale 보정의 한계

```python
현재 방식:
  angular_velocity_z_ = msg->angular.z * angular_scale_

문제:
  반시계 필요 scale: 89.94 / 51.48 = 1.747
  시계 필요 scale:   89.22 / 62.82 = 1.420
  차이: 1.747 - 1.420 = 0.327 (23% 차이!)
  
결론: 단일 scale 값으로 양방향 보정 불가능
```

#### 방향별 Scale 필요성
```cpp
// 이상적인 보정
if (angular_velocity_z > 0) {
    // 반시계
    angular_velocity_z_ *= 1.747;
} else {
    // 시계  
    angular_velocity_z_ *= 1.420;
}
```

---

### EKF 설정의 딜레마

#### Process Noise 트레이드오프

| Process Noise | 장점 | 단점 | 결과 |
|--------------|------|------|------|
| **0.01** (이전) | • 센서 변화 수용<br>• 동적 응답 좋음 | • IMU 무시<br>• Odom 100% 신뢰 | EKF = Odom |
| **0.001** | • 중간 융합 시도 | • 여전히 IMU 무시 | EKF ≈ Odom |
| **0.00005** (현재) | • IMU 높은 신뢰도<br>• 이론적 최적 | • **센서 거부 증가**<br>• **Innovation 임계값 초과**<br>• 상태 고착 | EKF 불안정 |

#### 권장 범위
```
최적 Process Noise: 0.0001 ~ 0.0005

근거:
  - IMU covariance (0.0001)보다 약간 큼
  - Odom covariance (0.01)보다 훨씬 작음
  - Innovation 허용 범위 유지
  - 동적 응답 확보
```

---

## 💡 해결 방안

### 🎯 **방안 1: 방향별 Angular Scale (추천)**

#### 구현
```cpp
// base.cpp 수정
void RobotBase::velCallback(const geometry_msgs::msg::Twist::SharedPtr msg)
{
    // ... 기존 코드 ...
    
    // 방향별 scale 적용
    double angular_scale_ccw = 1.747;  // 반시계 (언더측정 보정)
    double angular_scale_cw = 1.420;   // 시계 (오버측정 보정)
    
    if (msg->angular.z > 0.0) {
        angular_velocity_z_ = msg->angular.z * angular_scale_ccw;
    } else if (msg->angular.z < 0.0) {
        angular_velocity_z_ = msg->angular.z * angular_scale_cw;
    } else {
        angular_velocity_z_ = 0.0;
    }
    
    // ... 나머지 코드 ...
}
```

#### 기대 효과
```
반시계: 51.48° × 1.747 = 89.94° (IMU 일치!)
시계:   62.82° × 1.420 = 89.20° (IMU 89.22° 근사)
비대칭: < 1° (현재 17.71°에서 95% 개선)
```

---

### 🎯 **방안 2: Process Noise 재조정**

```yaml
# ekf_config.yaml
process_noise_covariance[11]: 0.0002  # 0.00005 → 0.0002

이유:
  - 0.00005는 너무 낮아 센서 거부 발생
  - 0.0002 = IMU covariance (0.0001)의 2배
  - Innovation 허용 범위 확대
  - 동적 응답 개선

Kalman Gain:
  K_IMU = 0.0002 / (0.0002 + 0.0001) = 0.67 (67%)
  → 센서 신뢰도 33% (적절)
  
  K_Odom = 0.0002 / (0.0002 + 0.01) = 0.02 (2%)
  → 센서 신뢰도 98% (IMU보다 Odom 우선)
```

---

### 🎯 **방안 3: Mahalanobis Distance 임계값 증가**

```yaml
# ekf_config.yaml
# Innovation 거부 임계값 완화
odom0_rejection_threshold: 10.0  # 기본값 보다 높게
imu0_rejection_threshold: 10.0

효과:
  - 센서 간 불일치 허용 범위 확대
  - Test 1 같은 경우에도 센서 수용
  - 하지만 이상치 필터링 약화 (부작용)
```

---

### 🎯 **방안 4: Odom Covariance 증가 (IMU 우선)**

```yaml
# ekf_config.yaml
odom0_twist_covariance[vyaw]: 0.1  # 0.01 → 0.1

효과:
  - Odom 신뢰도 감소
  - IMU 신뢰도 상대적 증가
  - 비대칭 문제 영향 감소

Kalman Gain (Process Noise 0.0002):
  K_IMU = 0.0002 / 0.0003 = 0.67 (유지)
  K_Odom = 0.0002 / 0.1002 = 0.002 (0.2%)
  → IMU 67%, Odom 33% (균형)
```

---

## 🔧 최종 권장 설정

### 단계적 적용

#### 1단계: 방향별 Scale (하드웨어 보정)
```cpp
// base.cpp
angular_scale_ccw: 1.747
angular_scale_cw: 1.420
```

#### 2단계: Process Noise 증가 (센서 수용성)
```yaml
# ekf_config.yaml
process_noise_covariance[11]: 0.0002
```

#### 3단계: Covariance 재조정 (센서 균형)
```yaml
imu0_angular_velocity_covariance: 0.0001  # 유지
odom0_twist_covariance[vyaw]: 0.05  # 0.01 → 0.05 (중간값)
```

#### 4단계: Rejection Threshold (안전망)
```yaml
odom0_rejection_threshold: 5.0
imu0_rejection_threshold: 5.0
```

---

## 📈 예상 결과

### 수정 전 (현재)
```
Test 1: IMU 89.94°, Odom 80.40°, EKF 63.84° ❌
Test 2: IMU 89.22°, Odom 98.11°, EKF 98.11° ❌
비대칭: 17.71° ❌
```

### 수정 후 (예상)
```
Test 1: IMU 89.94°, Odom 89.94°, EKF 89.50° ✅
Test 2: IMU 89.22°, Odom 89.20°, EKF 89.21° ✅
비대칭: < 1.0° ✅
EKF 융합: IMU 60% + Odom 40% ✅
```

---

## 🚀 즉시 실행 계획

### 우선순위 1: 방향별 Scale 적용

```bash
# 1. base.cpp 수정
nano ~/transbot_ws_ros2/src/transbot_base/src/base.cpp

# 2. 빌드
cd ~/transbot_ws_ros2
colcon build --packages-select transbot_base

# 3. 재시작
source install/setup.bash
ros2 launch sllidar_ros2 transbot_full_system.launch.py

# 4. 재테스트
python3 ekf_comparison_test.py
```

### 우선순위 2: EKF 설정 조정

```bash
# ekf_config.yaml 수정
# process_noise[11]: 0.00005 → 0.0002
# odom0_twist_covariance[vyaw]: 0.01 → 0.05

colcon build --packages-select sllidar_ros2
```

---

## 📝 결론

### 핵심 문제
1. ❌ **Odom 비대칭 17.71°**: 하드웨어 문제 (방향별 다른 측정)
2. ❌ **단일 Scale 한계**: 양방향 동시 보정 불가능
3. ❌ **Process Noise 과소**: 센서 거부, 상태 고착
4. ❌ **EKF 융합 실패**: 63.84° (둘 다 거부) 또는 98.11% (Odom만 신뢰)

### 해결 방향
1. ✅ **방향별 Scale**: 반시계 1.747, 시계 1.420
2. ✅ **Process Noise 증가**: 0.00005 → 0.0002
3. ✅ **Odom Covariance 증가**: 0.01 → 0.05
4. ✅ **Rejection Threshold 추가**: 5.0

### 최종 목표
- Odom 비대칭: 17.71° → < 1.0°
- EKF 융합: 실패 → IMU 60% + Odom 40%
- SLAM 드리프트: 제거
