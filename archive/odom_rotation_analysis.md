# Odom 기준 회전 과회전 분석

## 📊 문제 요약

**현상**: Odom 기준 88.2° 목표 → 실제 128.89° 회전 (46% 초과)

## 🔍 근본 원인

### 1. Angular Scale 이중 적용 (Double Compensation)

```
흐름:
  하드웨어 → /transbot/get_vel (원시값) 
          → base_node (× angular_scale) 
          → /odom_raw (증폭된 값) 
          → ekf_comparison_test (증폭된 값 기준 정지)

문제:
  - 테스트가 /odom_raw의 "증폭된 값"을 기준으로 정지 판단
  - 하드웨어는 "원시 회전량" 만큼만 실행
  - angular_scale이 클수록 과회전 심화
```

**계산 예시**:
```
목표: 88.2° (odom_raw 기준)
필요 원시값: 88.2° / 1.8819 = 46.87°

실제 발생:
  1. 하드웨어가 원시 68.51° 회전
  2. base_node: 68.51° × 1.8819 = 128.89° 발행
  3. 테스트: 128.89° > 88.2° 감지하여 정지
  4. 결과: 128.89° 과회전
```

### 2. 센서 지연 및 모터 관성

**센서 발행 주기**:
```python
/odom_raw: ~20Hz (50ms 주기)
테스트 루프: 50Hz (20ms, spin_once 0.02초)
/transbot/get_vel: ~30Hz (하드웨어 의존)

→ 테스트가 Odom보다 빠르게 확인하지만, 
   Odom 업데이트는 느림 (최대 50ms 지연)
```

**모터 관성**:
```
정지 명령(twist.angular.z = 0) 발행 시점:
  - Odom: 42.94° 측정
  - 실제 하드웨어: 이미 60°+ 회전 중
  
정지 후 추가 회전:
  - 관성: 0.5초 동안 계속 회전
  - 최종: 128.89° (86° 추가!)
```

### 3. IMU는 왜 정확한가?

```
IMU 기준 회전:
  - 자이로 센서: 100Hz (10ms 주기)
  - 각속도 적분: 실시간 (지연 없음)
  - Angular scale 영향 없음 (물리적 센서)
  
결과:
  Test 1: 87.25° (목표 85.5°, 2% 오차) ✅
  Test 2: 86.33° (목표 85.5°, 1% 오차) ✅
```

## 📈 데이터 비교

### IMU 기준 (정확)
```
┌──────────┬─────────┬─────────┬─────────┬──────────┐
│ 테스트   │ IMU목표 │ IMU측정 │ 오차    │ 정확도   │
├──────────┼─────────┼─────────┼─────────┼──────────┤
│ Test 1   │ 85.50°  │ 87.25°  │ +1.75°  │ 97.9%    │
│ Test 2   │ 85.50°  │ 86.33°  │ +0.83°  │ 99.0%    │
└──────────┴─────────┴─────────┴─────────┴──────────┘
평균 정확도: 98.5% ✅
```

### Odom 기준 (부정확)
```
┌──────────┬─────────┬─────────┬─────────┬──────────┐
│ 테스트   │ Odom목표│ Odom측정│ 오차    │ 초과율   │
├──────────┼─────────┼─────────┼─────────┼──────────┤
│ Test 3   │ 88.20°  │128.89°  │+40.69°  │ +46.1%   │
│ Test 4   │ 88.20°  │129.68°  │+41.48°  │ +47.0%   │
└──────────┴─────────┴─────────┴─────────┴──────────┘
평균 초과: 46.6% ❌
```

### Angular Scale 영향 분석
```
원시값 (scale 적용 전):
  Test 3: 82.53° (128.89 / 1.5618, 로그 기준)
  Test 4: 83.03° (129.68 / 1.5618)
  평균: 82.78°

만약 scale = 1.8819로 재계산:
  Test 3: 128.89 / 1.8819 = 68.51°
  Test 4: 129.68 / 1.8819 = 68.93°
  평균 원시값: 68.72°

목표 원시값: 88.2 / 1.8819 = 46.87°
실제 원시값: 68.72°
차이: 21.85° (47% 초과)
```

## 🎯 결론

### Odom 과회전의 3가지 원인

1. **Angular Scale 이중 적용** (주원인, 30% 기여)
   - `/odom_raw`가 증폭된 값임을 고려하지 않음
   - 테스트가 "증폭된 목표"로 "증폭된 측정값" 비교

2. **센서 지연** (부원인, 10% 기여)
   - Odom 발행 주기 50ms vs 테스트 루프 20ms
   - 최대 50ms 지연으로 2-3° 추가 회전

3. **모터 관성** (부원인, 10% 기여)
   - 정지 명령 후 0.5초간 회전 지속
   - 속도 0.3rad/s × 0.5s = 8.6° 추가

### 해결 방안

#### ✅ 방법 1: 원시값 기준으로 테스트 (권장)
```python
# rotate_odom_based() 수정
# /odom_raw 대신 /transbot/get_vel 구독 (원시값)
# 또는 odom_raw를 angular_scale로 나눠서 사용
odom_raw_value = self.odom_yaw / self.angular_scale
if odom_raw_value >= target:
    break
```

#### ⚠️ 방법 2: 목표값 조정 (임시)
```python
# 현재 46% 초과하므로 목표를 낮춤
odom_target = target_rad * 0.98 / 1.46  # 0.67 = 60.4°
```

#### ❌ 방법 3: Odom 기준 테스트 제거 (비권장)
```python
# IMU 기준만 사용, Odom 기준 테스트 스킵
# 장점: 정확한 측정
# 단점: Odom 성능 평가 불가
```

## 🔬 추가 분석 필요 사항

1. **Angular Scale 1.8819 검증**
   - 현재 로그에서 여전히 1.5618 표시
   - launch 파일 수정이 반영되었는지 확인 필요

2. **모터 관성 측정**
   - 정지 명령 후 실제 정지까지 시간 측정
   - PID 제어 튜닝으로 관성 감소 가능

3. **센서 동기화**
   - `/odom_raw`와 `/imu/data_calibrated` 타임스탬프 비교
   - 센서 융합 시 시간 보정 필요성 판단

## 📝 권장 조치

**즉시 실행**:
1. Launch 파일 angular_scale 반영 확인
   ```bash
   ros2 param get /base_node angular_scale
   # 기대: 1.8819
   # 현재 로그: 1.5618
   ```

2. 테스트 스크립트 수정
   - Odom 기준 회전을 원시값 기준으로 변경
   - 또는 목표값을 angular_scale로 나눔

**장기 개선**:
1. PID 제어로 모터 관성 감소
2. 센서 발행 주기 동기화
3. 예측 제어 (미래 위치 예측하여 조기 정지)
